## หลักการทำงานของ emulsiV
#### ต้องการให้โปรแกรมแสดงผลตัวอักษร T และ M จะมีการทำงานดังนี้

#### เริ่มต้นหน้าตาโปรแกรม

![image](https://user-images.githubusercontent.com/98943546/160089003-32543c05-3298-4dde-8e05-c354e6d83c74.png)

#### คำอธิบายตัวคำสั่ง

    addi ย่อมาจาก add immediate 
    lui ย่อมาจาก load upper immediate 
    lbu ย่อมาจาก load byte unsigned 
    beq ย่อมาจาก branch on equal 
    sb ย่อมาจาก store byte 
    jal ย่อมาจาก jump and link
    
    addi x1, x0, 32 โดยคำสั่งนี้ จะนำเลข 32 เข้าไปบรรจุใน x1 โดยมี x0เป็นค่าเริ่มต้น
    lui x2, 0xc0000000 โดยคำสั่งนี้ จะนำค่า 20 หลักแรกจากทางขวามาเก็บไว้ที่ x2
    lbu x3, 0(x1) โดยคำสั่งนี้จะนำข้อมูลจาก x1 เอาค่า byte จากตำแหน่งนั้นมาบรรจุที่ x3
    beq x3, x0, +16 โดยคำสั่งนี้เมื่อ x3 = x0 จะกระโดดจาก address ปัจจุบันไปข้างหน้า 16 ช่อง
    sb x3, 0(x2) โดยคำสั่งนี้ จะนำข้อมูลใน x3 ไปเก็บไว้ใน address x2
    addi x1, xa, 1 โดยคำสั่งนี้ จะน่าตำแหน่งที่1 ขยับขึ้นไปอีก1ตำแหน่ง
    jal x0, -16 โดยคำสั่งนี้ จะกระโดดจากตำแหน่งเดิมเดิม ถอยไป 16 ตำแหน่ง
    jal x0, 0 โดยคำสั่งนี้จะกระโดดอยู่กับที่

### Step 1
มีขั้นตอนดังนี้

![image](https://user-images.githubusercontent.com/98943546/160092088-90be9612-2a09-4831-9be9-727ec0b0616b.png)

    1.จาก 00000000 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000000

    2.ข้อมูลจาก 00000000 นั้นก็คือ 93000002 ที่บรรจุคำสั่ง addi x1, x0x 32 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น02000093

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง addi นำเข้าตัวเลข 00000020 จากการแปลงเลข 32 ฐาน 10 เป็น ฐาน 16
    
    4.ALU จะทราบว่า op ที่ใช้คือ add จากนั้นจะเรียกค่าเริ่มต้นที่x0 เป็นตั้วตั้งที่ a และเรียกค่า imm เป็นตัวบวกเพิ่มที่ b บวกกันแล้วได้ค่า r
    
    5.ค่าของ r จะถูกบรรจุใน x1
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000008
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000000 เป็น 00000004 
 
ได้ผลลัพธ์ดังรูป
 
 ![image](https://user-images.githubusercontent.com/98943546/160092707-d520da4d-4f39-4b94-b758-d71cff4e2edc.png)

### Step 2

มีขั้นตอนดังนี้

    1.จาก 00000004 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000004

    2.ข้อมูลจาก 00000004 นั้นก็คือ 370100c0 ที่บรรจุคำสั่ง lui x2, 0xc0000000 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็นc0000137

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง lui นำเข้าตัวเลข c0000000 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ b โดยจะเรียกค่า b มาจาก imm มาเป็น ค่า r ในทันที
    
    5.ค่าของ r จะถูกบรรจุใน x2
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 0000000c
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000004 เป็น 00000008
  
 ได้ผลลัพธ์ดังรูป 
 
 ![image](https://user-images.githubusercontent.com/98943546/160095748-a1d7f579-e58c-44ae-ae26-28bf009cb8a5.png)

### Step 3

มีขั้นตอนดังนี้

    1.จาก 00000008 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000008

    2.ข้อมูลจาก 00000008 นั้นก็คือ 83c10000 ที่บรรจุคำสั่ง Ibu x3, 0(x1) จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น0000c183

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง lbu นำเข้าข้อมูลจาก x1 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเรียกค่า a มาจาก x1 มาเป็น ค่า r ในทันที
    
    5.ค่าของ r ประมวณผลที่ Bus เรียก dataที่ address ตามค่าของ r ไปบรรจุเก็บที่ x3
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000010
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000008 เป็น 0000000c
  
ได้ผลลัพธ์ดังรูป 

![image](https://user-images.githubusercontent.com/98943546/160100244-0a0fd566-cc19-430c-9db6-13c235728020.png)

### Step 4

มีขั้นตอนดังนี้

    1.จาก 0000000c ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 0000000c

    2.ข้อมูลจาก 0000000c นั้นก็คือ 63880100 ที่บรรจุคำสั่ง beq x3, x0, +16 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น00018863

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง beq 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยเพิ่มค่าจาก address เดิม กระโดดไปข้างหน้า 16 ตำแหน่ง ได้ค่าตำแหน่ง r
    
    5.comparator ตรวจสอบความเท่ากันของ x0 และ x3 ซึ่งเมื่อไม่เท่ากันจะได้ผลลัพธ์เป็น False ทำให้ไม่เกิดการกระโดดตำแหน่งของ Address
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000014
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 0000000c เป็น 000000010
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160103232-eb0cabb6-b68e-4534-9c08-cc1c2abf34c7.png)

### Step 5

มีขั้นตอนดังนี้

    1.จาก 00000010 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000010

    2.ข้อมูลจาก 000000010 นั้นก็คือ 23003100 ที่บรรจุคำสั่ง sb x3, 0(x2) จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น00310023

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง beq 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยนำค่าที่ได้จาก x2 มาเป็น ค่า r
    
    5.ค่าr ที่ได้จะถูกบรรจุข้อมูล x3 แล้วไปแสดงผลที่จอdata c0000000 ได้อักษร T
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000018
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 0000000c เป็น 000000014
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160105037-52d99135-dec0-4707-b42d-548dda5244b2.png)

### Step 6

มีขั้นตอนดังนี้

    1.จาก 00000014 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000014

    2.ข้อมูลจาก 000000014 นั้นก็คือ 93801000 ที่บรรจุคำสั่ง addi x1, x1, 1 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น00108093

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง addi 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยนำค่าจาก x1 มาบวกเพิ่ม 1 ตำแหน่ง
    
    5.ค่าr ที่ได้จะถูกบรรจุใน x1
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 0000001c
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000014 เป็น 000000018
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160106663-43d89757-662c-4954-9056-8c4fdc809b62.png)

### Step 7

มีขั้นตอนดังนี้

    1.จาก 00000018 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000018

    2.ข้อมูลจาก 000000018 นั้นก็คือ 6ff01fff ที่บรรจุคำสั่ง jal x0, -16 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็นff1ff06f

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง jal
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยนำค่าจากตำแหน่งปัจจุบัน มาลบถอยกลับไป 16 ตำแหน่ง
    
    5.ค่า r ที่ได้จะมาแทนที่ตำแหน่ง pc กลายเป็น 00000008
    
    6.ค่า pc+4 จะกลายเป็น 0000000c
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000018 เป็น 000000008
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160108657-48550375-d5b9-4c7a-b97f-de22534135c6.png)

### Step 8

มีขั้นตอนดังนี้

    1.จาก 00000008 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000008

    2.ข้อมูลจาก 00000008 นั้นก็คือ 83c10000 ที่บรรจุคำสั่ง Ibu x3, 0(x1) จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น0000c183

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง lbu นำเข้าข้อมูลจาก x1 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเรียกค่า a มาจาก x1 มาเป็น ค่า r ในทันที
    
    5.ค่าของ r ประมวณผลที่ Bus เรียก dataที่ address ตามค่าของ r ไปบรรจุเก็บที่ x3
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000010
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000008 เป็น 0000000c
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160109438-3d97a317-08b6-4e11-956a-c549e76bf566.png)

### Step 9

มีขั้นตอนดังนี้

    1.จาก 0000000c ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 0000000c

    2.ข้อมูลจาก 0000000c นั้นก็คือ 63880100 ที่บรรจุคำสั่ง beq x3, x0, +16 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น00018863

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง beq 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยเพิ่มค่าจาก address เดิม กระโดดไปข้างหน้า 16 ตำแหน่ง ได้ค่าตำแหน่ง r
    
    5.comparator ตรวจสอบความเท่ากันของ x0 และ x3 ซึ่งเมื่อไม่เท่ากันจะได้ผลลัพธ์เป็น False ทำให้ไม่เกิดการกระโดดตำแหน่งของ Address
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000014
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 0000000c เป็น 000000010
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160110908-4d49a6a9-bd98-4841-afed-81a8c60a9325.png)

### Step 10

มีขั้นตอนดังนี้

    1.จาก 00000010 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000010

    2.ข้อมูลจาก 000000010 นั้นก็คือ 23003100 ที่บรรจุคำสั่ง sb x3, 0(x2) จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น00310023

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง beq 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยนำค่าที่ได้จาก x2 มาเป็น ค่า r
    
    5.ค่าr ที่ได้จะถูกบรรจุข้อมูล x3 แล้วไปแสดงผลที่จอdata c0000000 ได้อักษร M
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000018
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 0000000c เป็น 000000014
   
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160111302-a7b09211-9437-4b25-a2ef-ef1ce15e2fa1.png)

### Step 11

มีขั้นตอนดังนี้

    1.จาก 00000014 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000014

    2.ข้อมูลจาก 000000014 นั้นก็คือ 93801000 ที่บรรจุคำสั่ง addi x1, x1, 1 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น00108093

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง addi 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยนำค่าจาก x1 มาบวกเพิ่ม 1 ตำแหน่ง
    
    5.ค่าr ที่ได้จะถูกบรรจุใน x1
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 0000001c
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000014 เป็น 000000018
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160111596-b9fb7454-add6-4298-a748-c9ee74068073.png)

### Step 12

มีขั้นตอนดังนี้

    1.จาก 00000018 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000018

    2.ข้อมูลจาก 000000018 นั้นก็คือ 6ff01fff ที่บรรจุคำสั่ง jal x0, -16 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็นff1ff06f

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง jal
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยนำค่าจากตำแหน่งปัจจุบัน มาลบถอยกลับไป 16 ตำแหน่ง
    
    5.ค่า r ที่ได้จะมาแทนที่ตำแหน่ง pc กลายเป็น 00000008
    
    6.ค่า pc+4 จะกลายเป็น 0000000c
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000018 เป็น 000000008
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160111975-d7a536a9-ba83-4ca4-9ef4-a3ce15e6d961.png)

### Step 13

มีขั้นตอนดังนี้

    1.จาก 00000008 ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 00000008

    2.ข้อมูลจาก 00000008 นั้นก็คือ 83c10000 ที่บรรจุคำสั่ง Ibu x3, 0(x1) จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น0000c183

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง lbu นำเข้าข้อมูลจาก x1 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเรียกค่า a มาจาก x1 มาเป็น ค่า r ในทันที
    
    5.ค่าของ r ประมวณผลที่ Bus เรียก dataที่ address ตามค่าของ r ไปบรรจุเก็บที่ x3
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000010
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 00000008 เป็น 0000000c
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160112787-ba2f0baa-24e4-4943-a3b9-a87172f5a954.png)

### Step 14

มีขั้นตอนดังนี้

    1.จาก 0000000c ที่ pc ของ program counter จะเรียกใช้คำสั่งจาก address ที่ 0000000c

    2.ข้อมูลจาก 0000000c นั้นก็คือ 63880100 ที่บรรจุคำสั่ง beq x3, x0, +16 จะถูกส่งไปยัง data ที่ Bus แล้วถูกแปลงสลับด้านเป็น00018863

    3.ข้อมูล data จะถูกส่งไปประมวณผลที่ Instruction req. จะได้ผลลัพธ์ว่าคือคำสั่ง beq 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยเพิ่มค่าจาก address เดิม กระโดดไปข้างหน้า 16 ตำแหน่ง ได้ค่าตำแหน่ง r
    
    5.comparator ตรวจสอบความเท่ากันของ x0 และ x3 ซึ่งเมื่อเท่ากันจะได้ผลลัพธ์เป็น True ทำให้เกิดการกระโดดตำแหน่งของ Address ไป 16 ตำแหน่ง ที่ 0000001c
    
    6.ค่า pc+4 จะไปแทนที่ค่า pc เริ่มต้น และตัวมันเองจะบวกถูกบวกอีก 4 เพิ่่มเป็น 00000020
    
    7.แถบสีชมพูจะเลื่อนจากที่ address 0000000c เป็น 00000001c
  
ได้ผลลัพธ์ดังรูป

![image](https://user-images.githubusercontent.com/98943546/160113040-9b70e184-64fb-4a5d-a84c-99f693b448fe.png)

### หลังจาก step 14 เนื่องจาก ตรวจพบ 00 ซึ่งนั่นก็คือไม่พบขอมูลถัดไป โปรแกรมจะวนลูปอยู่ที่เดิมที่ตำแหน่ง 0000001c
